var documenterSearchIndex = {"docs":
[{"location":"4-optimal-powerflow.html#Tutorial-4:-solving-optimal-power-flow-with-MadNLP","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: solving optimal power flow with MadNLP","text":"","category":"section"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"The previous tutorial was the last step we needed to implement the full optimal power flow problem with MadNLP. It just remains to add the following elements to the model:","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"the cost to run each power generator;\nthe line flow constraints;\nthe voltage angle constraints;","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"We start the tutorial again by importing the usual packages:","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"using LinearAlgebra\nusing SparseArrays\n\nusing NLPModels\nusing ExaModels\n\nusing JLD2\n\ninclude(\"utils.jl\")","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"We import a small instance:","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"DATA_DIR = joinpath(splitdir(Base.active_project())[1], \"instances\")\ndata = JLD2.load(joinpath(DATA_DIR, \"case9.jld2\"))[\"data\"]","category":"page"},{"location":"4-optimal-powerflow.html#Optimal-power-flow-model","page":"Tutorial 4: Optimal Power Flow","title":"Optimal power flow model","text":"","category":"section"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"We implement in ExaModels the AC optimal power flow problem in the function acopf_model:","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"function acopf_model(\n    data;\n    backend = nothing,\n    T = Float64,\n    kwargs...,\n)\n    w = ExaCore(T; backend = backend)\n    va = variable(w, length(data.bus))\n    vm = variable(\n        w,\n        length(data.bus);\n        start = data.vm0,\n        lvar = data.vmin,\n        uvar = data.vmax,\n    )\n    pg = variable(w, length(data.gen); start=data.pg0, lvar = data.pmin, uvar = data.pmax)\n    qg = variable(w, length(data.gen); start=data.qg0, lvar = data.qmin, uvar = data.qmax)\n    p = variable(w, length(data.arc); lvar = -data.rate_a, uvar = data.rate_a)\n    q = variable(w, length(data.arc); lvar = -data.rate_a, uvar = data.rate_a)\n\n    o = objective(\n        w,\n        g.cost1 * pg[g.i]^2 + g.cost2 * pg[g.i] + g.cost3 for g in data.gen\n    )\n\n    c1 = constraint(w, va[i] for i in data.ref_buses)\n\n    # Active power flow, FR\n    c2 = constraint(\n        w,\n        p[b.f_idx] - b.c5 * vm[b.f_bus]^2 -\n        b.c3 * (vm[b.f_bus] * vm[b.t_bus] * cos(va[b.f_bus] - va[b.t_bus])) -\n        b.c4 * (vm[b.f_bus] * vm[b.t_bus] * sin(va[b.f_bus] - va[b.t_bus])) for\n        b in data.branch\n    )\n    # Reactive power flow, FR\n    c3 = constraint(\n        w,\n        q[b.f_idx] +\n        b.c6 * vm[b.f_bus]^2 +\n        b.c4 * (vm[b.f_bus] * vm[b.t_bus] * cos(va[b.f_bus] - va[b.t_bus])) -\n        b.c3 * (vm[b.f_bus] * vm[b.t_bus] * sin(va[b.f_bus] - va[b.t_bus])) for\n        b in data.branch\n    )\n    # Active power flow, TO\n    c4 = constraint(\n        w,\n        p[b.t_idx] - b.c7 * vm[b.t_bus]^2 -\n        b.c1 * (vm[b.t_bus] * vm[b.f_bus] * cos(va[b.t_bus] - va[b.f_bus])) -\n        b.c2 * (vm[b.t_bus] * vm[b.f_bus] * sin(va[b.t_bus] - va[b.f_bus])) for\n        b in data.branch\n    )\n    # Reactive power flow, TO\n    c5 = constraint(\n        w,\n        q[b.t_idx] +\n        b.c8 * vm[b.t_bus]^2 +\n        b.c2 * (vm[b.t_bus] * vm[b.f_bus] * cos(va[b.t_bus] - va[b.f_bus])) -\n        b.c1 * (vm[b.t_bus] * vm[b.f_bus] * sin(va[b.t_bus] - va[b.f_bus])) for\n        b in data.branch\n    )\n\n    # Voltage angle difference\n    c6 = constraint(\n        w,\n        va[b.f_bus] - va[b.t_bus] for b in data.branch;\n        lcon = data.angmin,\n        ucon = data.angmax,\n    )\n    # Line flow constraints\n    c7 = constraint(\n        w,\n        p[b.f_idx]^2 + q[b.f_idx]^2 - b.rate_a_sq for b in data.branch;\n        lcon = fill!(similar(data.branch, Float64, length(data.branch)), -Inf),\n    )\n    c8 = constraint(\n        w,\n        p[b.t_idx]^2 + q[b.t_idx]^2 - b.rate_a_sq for b in data.branch;\n        lcon = fill!(similar(data.branch, Float64, length(data.branch)), -Inf),\n    )\n\n    # Active power balance\n    c9 = constraint(w, b.pd + b.gs * vm[b.i]^2 for b in data.bus)\n    c11 = constraint!(w, c9, a.bus => p[a.i] for a in data.arc)\n    c13 = constraint!(w, c9, g.bus => -pg[g.i] for g in data.gen)\n    # Reactive power balance\n    c10 = constraint(w, b.qd - b.bs * vm[b.i]^2 for b in data.bus)\n    c12 = constraint!(w, c10, a.bus => q[a.i] for a in data.arc)\n    c14 = constraint!(w, c10, g.bus => -qg[g.i] for g in data.gen)\n\n    return ExaModel(w; kwargs...)\nend","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"Solving case9 is straightforward using MadNLP:","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"using MadNLP\n\nnlp = acopf_model(data)\nresults = madnlp(nlp)\nnothing","category":"page"},{"location":"4-optimal-powerflow.html#Solving-optimal-power-flow-on-the-GPU","page":"Tutorial 4: Optimal Power Flow","title":"Solving optimal power flow on the GPU","text":"","category":"section"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"For solving the optimal power flow model on the GPU, the set-up is similar to what we have detailed in the tutorial 3. We start by importing MadNLPGPU, and we instantiate a new optimal power flow instance on the GPU:","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"using CUDA\nusing MadNLPGPU\n\nnlp_gpu = acopf_model(data; backend=CUDABackend())","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"Solving the problem using cuDSS simply amounts to","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"results = madnlp(nlp_gpu)\nnothing","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"The instance case9 is too small to get any significant speed-up compared to the CPU. However, we can solve a larger instance just by importing new data. For instance, to solve the case 10000_goc:","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"data = JLD2.load(joinpath(DATA_DIR, \"pglib_opf_case10000_goc.jld2\"))[\"data\"]\nnlp_gpu = acopf_model(data; backend=CUDABackend())\nresults = madnlp(nlp_gpu)\nnothing","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"","category":"page"},{"location":"4-optimal-powerflow.html","page":"Tutorial 4: Optimal Power Flow","title":"Tutorial 4: Optimal Power Flow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"5-exa-models-power.html#Tutorial-5:-solving-the-optimal-power-flow-with-ExaModelsPower.jl","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: solving the optimal power flow with ExaModelsPower.jl","text":"","category":"section"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"In the previous tutorial, we have seen how to implement power flow equations and optimal power flow using ExaModels.jl. In this tutorial, we will see how to use the off-the-shelf modeling library ExaModelsPower.jl to create optimal power flow models, and how to solve them with GPUs.","category":"page"},{"location":"5-exa-models-power.html#What-is-ExaModelsPower.jl?","page":"Tutorial 5: ExaModelsPower.jl","title":"What is ExaModelsPower.jl?","text":"","category":"section"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"ExaModelsPower.jl can model OPF problems using the ExaModels package to generate models that can be solved using either CPU or GPU. This tutorial will demonstrate how ExaModelsPower.jl can be leveraged to solve different versions of the OPF, and how the user can customize the solving technique to better match their needs. Currently, all models generated by ExaModelsPower represent the full, AC version of the OPF formulation without any modifications (e.g, convex relaxations).","category":"page"},{"location":"5-exa-models-power.html#Getting-started","page":"Tutorial 5: ExaModelsPower.jl","title":"Getting started","text":"","category":"section"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"ExaModelsPower.jl package can be installed via","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"using Pkg\nPkg.add(url=\"https://github.com/exanauts/ExaModelsPower.jl.git\")","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"We will start by importing the necessary packages.","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"using ExaModelsPower, CUDA, MadNLPGPU","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"ExaModelsPower.jl provides a set of functions to create power flow models, CUDA.jl provides the GPU backend, and MadNLPGPU.jl provides the solver interface to solve the models on the GPU.","category":"page"},{"location":"5-exa-models-power.html#Static-optimal-power-flow","page":"Tutorial 5: ExaModelsPower.jl","title":"Static optimal power flow","text":"","category":"section"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"We will begin by constructing and solving a static OPF using the function opf_model. A static OPF problem can be created by the following one-liner:","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"model, vars, cons = opf_model(\n    \"pglib_opf_case118_ieee.m\";\n    backend = CUDABackend(),\n    form = :polar,\n    T = Float64\n)","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"For the static OPF, the only input required is the filename for the OPF matpower file. The file does not need to be locally installed, and it will be automatically downloaded from power-grid-library if the file is not found in the user's data folder. If keyword T is not specified, the numerical type will default to Float64. The backend defaults to nothing (used on CPU) and the form will default to polar coordinates. Here, we use CUDABackend() to create the problem on an NVIDIA GPU, and form = :polar to specify that the voltage angles will be represented in polar coordinates. The function returns a tuple containing the model, the variables, and the constraints.","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"Once the model is built, we can solve it using the madnlp function from MadNLPGPU.jl. This function will automatically detect the model type and solve it using the appropriate solver.","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"result = madnlp(model; tol=1e-6)","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"Once a solution has been generated, the values of any of the variables in the model can be unpacked using the vars NamedTuple","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"using ExaModels\nsolution(result, vars.vm)","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"Result also stores the objective value","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"result.objective","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"ExaModelsPower supports solving the OPF in either polar or rectangular coordinates. For example, to create a rectangular OPF model, we can simply change the form keyword argument to :rectangular:","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"model, vars, cons = opf_model(\n    \"pglib_opf_case118_ieee.m\";\n    form = :rect\n)\nresult = madnlp(model; tol=1e-6)\n\n# Other features","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"ExaModelsPower.jl is currently under active development. We are currently implementing the following formulations:","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"Multi-period OPF (with ramping constraints and/or storage)\nSecurity-constrained OPF (with N-1 constraints)\nDistribution system OPF (with unbalanced three-phase models)","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"For more information on the current status of ExaModelsPower.jl, please refer to the ExaModelsPower.jl documentation.","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"","category":"page"},{"location":"5-exa-models-power.html","page":"Tutorial 5: ExaModelsPower.jl","title":"Tutorial 5: ExaModelsPower.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"1-powerflow.html#Tutorial-1:-solving-the-power-flow-equations-with-ExaModels","page":"Tutorial 1: Power Flow","title":"Tutorial 1: solving the power-flow equations with ExaModels","text":"","category":"section"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"In this tutorial, we detail how to use ExaModels to solve the power flow equations on the GPU. We start by describing the model we use, and then write a basic Newton solver in Julia.","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"While there are off-the-shelf solvers, like Ipopt or MadNLP.jl, we provide this tutorial to illustrate how to directly interact with ExaModels to evaluate the model functions and the derivative, and how to do so efficiently on the GPU. This turorial can be useful for those who want to implement their own solvers, or for those who want to understand how the off-the-shelf solvers work under the hood.","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We start by importing the usual packages (including JLD2, a package to import serialized data in Julia)","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"using LinearAlgebra\nusing SparseArrays\n\nusing NLPModels\nusing ExaModels\n\nusing JLD2\n\ninclude(\"utils.jl\")","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We load the classical case9ieee instance, here generated using the MATPOWER file found in the matpower repo.","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"DATA_DIR = joinpath(splitdir(Base.active_project())[1], \"instances\")\ndata = JLD2.load(joinpath(DATA_DIR, \"case9.jld2\"))[\"data\"];\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"The number of buses, generators and lines are:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"nbus = length(data.bus)\nngen = length(data.gen)\nnlines = length(data.branch);\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We load the indexes of the PV buses and the generators at the PV buses:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"pv_buses = get_pv_buses(data)\nfree_gen = get_free_generators(data);\nnothing #hide","category":"page"},{"location":"1-powerflow.html#Implementing-the-power-flow-equations-with-ExaModels","page":"Tutorial 1: Power Flow","title":"Implementing the power flow equations with ExaModels","text":"","category":"section"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We model the power flow equations using the AC polar formulation. The AC polar formulation requires the following variables:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"The voltage magnitude at buses v_m\nThe voltage angles at buses v_a\nThe active power generation p_g\nThe reactive power generation q_g\nThe active power flow through the lines p\nThe reactive power flow through the lines q","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"The variables p and q are dependent variables depending on the voltage magnitudes and angles at the adjacent nodes. The structure of the problem implies that the degree-of-freedoms are the voltage magnitude at the PV and REF buses, the voltage angle at the REF buses (usually set equal to 0) and the active power generation at the PV buses.","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We define the variables in ExaModels.","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"core = ExaCore()\nva = variable(core, nbus)\nvm = variable(core, nbus; start = data.vm0)\npg = variable(core, ngen; start = data.pg0)\nqg = variable(core, ngen; start = data.qg0)\np = variable(core, 2*nlines)  # FR and TO lines\nq = variable(core, 2*nlines); # FR and TO lines\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We set the initial values in vm, pg and qg using the setpoint values specified in the matpower file.","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We fix the degree-of-freedom at their setpoint using equality constraints. We iterate over the reference buses to set their voltage angle to 0,","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"c1 = constraint(core, va[i] for i in data.ref_buses);\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"over the PV buses to set the voltage magnitude to the setpoint,","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"c01 = constraint(core, vm[i] for i in pv_buses; lcon=data.vm0[pv_buses], ucon=data.vm0[pv_buses]);\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"and finally over the generators to fix the active power generation (except at the REF buses):","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"c02 = constraint(core, pg[i] for i in free_gen; lcon=data.pg0[free_gen], ucon=data.pg0[free_gen]);\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We use the same model as in MATPOWER to model the transmission lines, based on the standard π transmission line model in series with an ideal phase-shifting transformer. Using the polar formulation, the active power through the line (i j) is defined as at the from end of the branch","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"  p_i j = v_mi (g_i i v_mi\n  + g_i j v_m j cos(v_a i - v_a j)\n  + b_i j v_m j sin(v_a i - v_a j))\n","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"and the reactive power is defined similarly at the from end of the branch","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"  q_i j = v_mi (g_i i v_mi\n  + g_i j  v_m j sin(v_a i - v_a j)\n  - b_i j  v_m j cos(v_a i - v_a j))\n","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"Using ExaModels, these two equations translate to the following constraints at the from end of each branch","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"c2 = constraint(\n    core,\n    p[b.f_idx] - b.c5 * vm[b.f_bus]^2 -\n    b.c3 * (vm[b.f_bus] * vm[b.t_bus] * cos(va[b.f_bus] - va[b.t_bus])) -\n    b.c4 * (vm[b.f_bus] * vm[b.t_bus] * sin(va[b.f_bus] - va[b.t_bus])) for\n    b in data.branch\n)\nc3 = constraint(\n    core,\n    q[b.f_idx] +\n    b.c6 * vm[b.f_bus]^2 +\n    b.c4 * (vm[b.f_bus] * vm[b.t_bus] * cos(va[b.f_bus] - va[b.t_bus])) -\n    b.c3 * (vm[b.f_bus] * vm[b.t_bus] * sin(va[b.f_bus] - va[b.t_bus])) for\n    b in data.branch\n);\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"Similarly, the power flow at the to end of each branch is","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"c4 = constraint(\n    core,\n    p[b.t_idx] - b.c7 * vm[b.t_bus]^2 -\n    b.c1 * (vm[b.t_bus] * vm[b.f_bus] * cos(va[b.t_bus] - va[b.f_bus])) -\n    b.c2 * (vm[b.t_bus] * vm[b.f_bus] * sin(va[b.t_bus] - va[b.f_bus])) for\n    b in data.branch\n)\nc5 = constraint(\n    core,\n    q[b.t_idx] +\n    b.c8 * vm[b.t_bus]^2 +\n    b.c2 * (vm[b.t_bus] * vm[b.f_bus] * cos(va[b.t_bus] - va[b.f_bus])) -\n    b.c1 * (vm[b.t_bus] * vm[b.f_bus] * sin(va[b.t_bus] - va[b.f_bus])) for\n    b in data.branch\n);\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"It remains to write the power flow balance equations at each bus. They are defined for the active power flow at bus i=1  n_bus","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"   p_g i - p_d i - g_shi v_mi^2 = _j  N(i) p_ij\n","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"and for the reactive power flow at bus i= 1  n_bus","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"   q_g i - q_d i - b_shi v_mi^2 = _j  N(i) q_ij\n","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"Note that both set of constraints sum over the power flow at the adjacent lines. As we have seen before, ExaModels implements the sum as a reduction over a given iterator. As a consequence, we will evaluate the first terms p_g i - p_d i - g_si v_mi^2 apart from the sum _j  N(i) p_ij in the expression tree defining the active power flow balance. This translates to the following syntax in ExaModels. We first iterate over all the buses to define the first part in the expressions:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"active_flow_balance = constraint(core, b.pd + b.gs * vm[b.i]^2 for b in data.bus);\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"Then we modify the constraint inplace to add the contribution of the adjacent lines","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"constraint!(core, active_flow_balance, a.bus => p[a.i] for a in data.arc);\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"and finally, we add the contribution of the generators connected to each bus:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"constraint!(core, active_flow_balance, g.bus => -pg[g.i] for g in data.gen);\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We follow the same procedure for the reactive power flow balance:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"reactive_flow_balance = constraint(core, b.qd - b.bs * vm[b.i]^2 for b in data.bus)\nconstraint!(core, reactive_flow_balance, a.bus => q[a.i] for a in data.arc)\nconstraint!(core, reactive_flow_balance, g.bus => -qg[g.i] for g in data.gen);\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"warning: Warning\nAvoid using summation inside the generator unless the summation has a fixed, relatively small number of terms. This restriction is intentional, as a variable number of terms can lead to an increased number of kernels needing compilation. constraint! helps minimize the required number of kernels by handling the summation of additional terms with a single, separate kernel.","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We have now all the equations to evaluate the power flow! Note that we have defined all the expressions inside core: to evaluate them, we convert the ExaCore to a proper ExaModel as:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"nlp = ExaModel(core);\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"Using NLPModels API, evaluating the power flow at the initial setpoint amounts to","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"x0 = NLPModels.get_x0(nlp)\nc = NLPModels.cons(nlp, x0)","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"Remember that the first equations c1, c01, and c02 are fixing the degree-of-freedom to their setpoint. The power flow equations per-se are defined by the remaining equations, starting with the constraint c2. We use the attribute offset to determine where does the power flow eq. start in the model","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"m_fixed = c2.offset","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"Using this offset, we can compute the norm-2 of the initial residual:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"residual = norm(c[m_fixed+1:end])","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"If the power flow equations are satisfied, the residual should be zero, which it currently is not. Recall that our degrees of freedom include:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"voltage angle at reference buses\nvoltage magnitude at PV and reference buses\nactive power generation at PV buses","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We maintain these degrees of freedom fixed and solve for the dependent variables that satisfy the power flow equations for this specified setpoint. This is achieved by applying the Newton method to the power flow balance equations.","category":"page"},{"location":"1-powerflow.html#Solving-the-power-flow-equations-using-the-Newton-algorithm","page":"Tutorial 1: Power Flow","title":"Solving the power flow equations using the Newton algorithm","text":"","category":"section"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We load the numbers of variables, constraints and nonzeros in the Jacobian (all these values are provided automatically by ExaModels):","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"n = NLPModels.get_nvar(nlp)\nm = NLPModels.get_ncon(nlp)\nnnzj = NLPModels.get_nnzj(nlp);\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We load the index of the degree-of-freedom in our model using a utility function:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"ind_dof = get_index_dof(data)","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"and the set of dependent variables is defined as the complement:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"ind_dep = setdiff(1:n, ind_dof)","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We start by evaluating the Jacobian using NLPModels. We get the sparsity pattern of our Jacobian in COO format directly by using:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"Ji = similar(x0, Int, nnzj)\nJj = similar(x0, Int, nnzj)\nNLPModels.jac_structure!(nlp, Ji, Jj)","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"and we evaluate the nonzero values using","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"Jx = similar(x0, nnzj)\nNLPModels.jac_coord!(nlp, x0, Jx)","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"Julia uses the CSC format by default to store sparse matrix. We can convert our Jacobian to CSC directly using Julia syntax:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"J = sparse(Ji, Jj, Jx, m, n)","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"And we can extract from the Jacobian the part associated to the power flow balance:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"G = J[m_fixed+1:end, ind_dep]","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"This is exactly the matrix we need in the Newton algorithm.","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"Although one can obtain G with the above strategy, we want to implement a more efficient, non-allocating routine that can be used within Newton's method. To implement this, we just need one last routine to pass the data from the vector Jx (in COO format) to the nonzeros in the CSC matrix G. To this end, we use the following trick:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"Jx .= 1:nnzj # store index of each coefficient in Jx\nJ = sparse(Ji, Jj, Jx, m, n)  # convert the COO matrix to CSC\nG = J[m_fixed+1:end, ind_dep] # extract the submatrix associated to the power flow equations\ncoo_to_csc = convert.(Int, nonzeros(G))","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"info: Info\nObserve that the sparsity pattern of G is not symmetric, as it is the case in matpower. Indeed,  we model explicitly the active and reactive power flow (p, q) through each branch, whereas matpower keeps them implicit (and as a consequence uses a much more compact model).","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"Using this vector of indices, we can automatically pass the data from Jx to G with:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"nonzeros(G) .= @view Jx[coo_to_csc];\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We are now in place to solve the power flow equations. We start by importing KLU:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"using KLU","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"and we initialize the Newton algorithm by evaluating the model at the initial point:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"x = copy(x0)\nc = similar(x0, m)\nd = similar(x0, length(ind_dep))     # descent direction\nresidual = view(c, m_fixed+1:m)      # get subvector associated to the power flow residual\n\nNLPModels.cons!(nlp, x, c)\nNLPModels.jac_coord!(nlp, x, Jx)\nnonzeros(G) .= @view Jx[coo_to_csc];\nnothing #hide","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We compute the symbolic factorization using the direct solver KLU:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"ls = klu(G)","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"The Newton algorithm writes:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"max_iter = 10\ntol = 1e-8\n\n@info \"Solving the power flow equations with Newton\"\nfor i in 1:max_iter\n    @info \"It: $(i) residual: $(norm(residual))\"\n    if norm(residual) <= tol\n        break\n    end\n    NLPModels.jac_coord!(nlp, x, Jx) # Update values in Jacobian\n    nonzeros(G) .= @view Jx[coo_to_csc]\n    klu!(ls, G)                      # Update numerical factorization\n    ldiv!(d, ls, residual)           # Compute Newton direction using a backsolve\n    x[ind_dep] .-= d\n    NLPModels.cons!(nlp, x, c)\nend","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We observe that the Newton algorithm has converged in 5 iterations! The final residual is not exactly 0 but is close enough (close to 1e-14). We can recover the solution directly by looking at the values in the vector x. For the voltage angle:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"va_sol = x[1:nbus]","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"and for the voltage magnitude:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"vm_sol = x[nbus+1:2*nbus]","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"We have implemented the generation of the model in a function powerflow_model, and the previous Newton algorithm in a separate function solve_power_flow:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"include(\"powerflow.jl\")","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"You can test the performance of Newton on various cases using the following code:","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"data = JLD2.load(joinpath(DATA_DIR, \"pglib_opf_case1354_pegase.jld2\"))[\"data\"]\n\nnlp = powerflow_model(data)\nresults = solve_power_flow(nlp)\nnothing","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"","category":"page"},{"location":"1-powerflow.html","page":"Tutorial 1: Power Flow","title":"Tutorial 1: Power Flow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"3-constrained-powerflow.html#Tutorial-3:-solving-constrained-power-flow-with-MadNLP","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: solving constrained power flow with MadNLP","text":"","category":"section"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"In this third tutorial, we look at a variant of the power flow equations, where we incorporate operational constraints on the different variables: we add bounds on the voltage magnitude, the active and the reactive power genenerations. Our goal is to identify if a solution of the power flow equations exists within these bounds (without implementing a proper PV/PQ switching routine as in matpower).","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"We start by importing the usual packages:","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"using LinearAlgebra\nusing SparseArrays\n\nusing NLPModels\nusing ExaModels\n\nusing JLD2\n\ninclude(\"utils.jl\")","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"We import a small instance:","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"DATA_DIR = joinpath(splitdir(Base.active_project())[1], \"instances\")\ndata = JLD2.load(joinpath(DATA_DIR, \"case9.jld2\"))[\"data\"]\nngen = length(data.gen)\nnbus = length(data.bus)\nnlines = length(data.branch);\nnothing #hide","category":"page"},{"location":"3-constrained-powerflow.html#Constrained-power-flow","page":"Tutorial 3: Constrained Power Flow","title":"Constrained power flow","text":"","category":"section"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"On the contrary to the Tutorial 2, we consider again the power flow equations with a batch size equal to 1. The bounds are easy to define in ExaModels, as we can pass them to the model directly when calling the function variable using the keywords lvar and uvar. We use the bounds specified in the data. As a results, the variables are initialized as follows:","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"core = ExaCore()\n\nva = variable(core, nbus)\nvm = variable(core, nbus; start = data.vm0, lvar = data.vmin, uvar = data.vmax)\npg = variable(core, ngen;  start=data.pg0, lvar = data.pmin, uvar = data.pmax)\nqg = variable(core, ngen;  start=data.qg0, lvar = data.qmin, uvar = data.qmax)\np = variable(core, 2*nlines)\nq = variable(core, 2*nlines);\nnothing #hide","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"As we obtain a bounded feasible set, we are not guaranteed to find a solution of the power flow constraints satisfying also the bound constraints. As a result, we relax the power flow constraints and penalize their violation in the objective using a ℓ1 penalty. If we denote by g(x) = 0 the original power flow equations, the relaxed model writes","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"g(x) = σ_p - σ_n     σ_p  0    σ_n  0","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"and we define the penalization in the objective as f(σ) = 1^ σ_P + 1^ σ_N.","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"The variables σ and the objective are defined in ExaModels as","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"spp = variable(core, nbus; lvar=0.0)\nspn = variable(core, nbus; lvar=0.0)\nsqp = variable(core, nbus; lvar=0.0)\nsqn = variable(core, nbus; lvar=0.0)\n\nobj = objective(\n    core,\n    spp[b.i] + spn[b.i] + sqp[b.i] + sqn[b.i] for b in data.bus\n)","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"We implement the full power flow model with bounds in the following function:","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"function constrained_power_flow_model(\n    data;\n    backend = nothing,\n    T = Float64,\n    kwargs...\n)\n    ngen = length(data.gen)\n    nbus = length(data.bus)\n    nlines = length(data.branch)\n\n    pv_buses = get_pv_buses(data)\n    free_gen = get_free_generators(data)\n\n    w = ExaCore(T; backend = backend)\n\n    va = variable(w, nbus)\n    vm = variable(\n        w,\n        nbus;\n        start = data.vm0,\n        lvar = data.vmin,\n        uvar = data.vmax,\n    )\n    pg = variable(w, ngen;  start=data.pg0, lvar = data.pmin, uvar = data.pmax)\n    qg = variable(w, ngen;  start=data.qg0, lvar = data.qmin, uvar = data.qmax)\n    p = variable(w, 2*nlines)\n    q = variable(w, 2*nlines)\n    # slack variables\n    spp = variable(w, nbus; lvar=0.0)\n    spn = variable(w, nbus; lvar=0.0)\n    sqp = variable(w, nbus; lvar=0.0)\n    sqn = variable(w, nbus; lvar=0.0)\n\n    # Fix variables to setpoint\n    c1 = constraint(w, va[i] for i in data.ref_buses)\n    c01 = constraint(w, vm[i] for i in pv_buses; lcon=data.vm0[pv_buses], ucon=data.vm0[pv_buses])\n    c02 = constraint(w, pg[i] for i in free_gen; lcon=data.pg0[free_gen], ucon=data.pg0[free_gen])\n\n    # Active power flow, FR\n    c2 = constraint(\n        w,\n        p[b.f_idx] - b.c5 * vm[b.f_bus]^2 -\n        b.c3 * (vm[b.f_bus] * vm[b.t_bus] * cos(va[b.f_bus] - va[b.t_bus])) -\n        b.c4 * (vm[b.f_bus] * vm[b.t_bus] * sin(va[b.f_bus] - va[b.t_bus])) for\n        b in data.branch\n    )\n    # Reactive power flow, FR\n    c3 = constraint(\n        w,\n        q[b.f_idx] +\n        b.c6 * vm[b.f_bus]^2 +\n        b.c4 * (vm[b.f_bus] * vm[b.t_bus] * cos(va[b.f_bus] - va[b.t_bus])) -\n        b.c3 * (vm[b.f_bus] * vm[b.t_bus] * sin(va[b.f_bus] - va[b.t_bus])) for\n        b in data.branch\n    )\n    # Active power flow, TO\n    c4 = constraint(\n        w,\n        p[b.t_idx] - b.c7 * vm[b.t_bus]^2 -\n        b.c1 * (vm[b.t_bus] * vm[b.f_bus] * cos(va[b.t_bus] - va[b.f_bus])) -\n        b.c2 * (vm[b.t_bus] * vm[b.f_bus] * sin(va[b.t_bus] - va[b.f_bus])) for\n        b in data.branch\n    )\n    # Reactive power flow, TO\n    c5 = constraint(\n        w,\n        q[b.t_idx] +\n        b.c8 * vm[b.t_bus]^2 +\n        b.c2 * (vm[b.t_bus] * vm[b.f_bus] * cos(va[b.t_bus] - va[b.f_bus])) -\n        b.c1 * (vm[b.t_bus] * vm[b.f_bus] * sin(va[b.t_bus] - va[b.f_bus])) for\n        b in data.branch\n    )\n\n    # Power flow constraints\n    c9 = constraint(w, b.pd + b.gs * vm[b.i]^2 - spp[b.i] + spn[b.i] for b in data.bus)\n    c10 = constraint(w, b.qd - b.bs * vm[b.i]^2 - sqp[b.i] + sqn[b.i] for b in data.bus)\n    c11 = constraint!(w, c9, a.bus => p[a.i] for a in data.arc)\n    c12 = constraint!(w, c10, a.bus => q[a.i] for a in data.arc)\n    c13 = constraint!(w, c9, g.bus => -pg[g.i] for g in data.gen)\n    c14 = constraint!(w, c10, g.bus => -qg[g.i] for g in data.gen)\n\n    o = objective(\n        w,\n        spp[b.i] + spn[b.i] + sqp[b.i] + sqn[b.i] for b in data.bus\n    )\n    return ExaModel(w; kwargs...)\nend","category":"page"},{"location":"3-constrained-powerflow.html#Solution-with-the-interior-point-solver-MadNLP","page":"Tutorial 3: Constrained Power Flow","title":"Solution with the interior-point solver MadNLP","text":"","category":"section"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"We generate a new model using our function constrained_power_flow_model:","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"nlp = constrained_power_flow_model(data)\nnothing","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"As we have incorporated bounds on our optimization variables, the constrained power flow is not solvable using the Newton method we used in the two previous tutorials. However, it is good candidate for an interior-point method, as implemented in MadNLP.","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"MadNLP takes as input any model following the AbstractNLPModel abstraction, as it is the case with our model nlp. As a consequence, solving the constrained power flow equations simply amounts to call the function madnlp:","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"using MadNLP\nresults = madnlp(nlp)\nnothing","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"We observe that MadNLP converges with a final objective close to 0, meaning that the power flow is feasible within the bounds. The solution returned by MadNLP is the same as those returned previously in Tutorial 1 by our custom Newton solver:","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"vm = results.solution[nbus+1:2*nbus]","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"Observe that this is not the case on most instances. E.g., MadNLP converges to a solution with a nonzero objective on 89pegase, meaning this instance does not have a solution of the power flow equations within bounded feasibility set.","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"data = JLD2.load(joinpath(DATA_DIR, \"pglib_opf_case89_pegase.jld2\"))[\"data\"]\nnlp = constrained_power_flow_model(data)\nresults = madnlp(nlp)\nnothing","category":"page"},{"location":"3-constrained-powerflow.html#Deporting-the-solution-on-the-GPU","page":"Tutorial 3: Constrained Power Flow","title":"Deporting the solution on the GPU","text":"","category":"section"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"Like our previous Newton algorithm, MadNLP supports offloading the solution of the model on the GPU using the extension MadNLPGPU:","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"using CUDA\nusing MadNLPGPU","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"Once MadNLPGPU is imported, you just have to instantiate the previous model on the GPU to solve it using the same madnlp function:","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"nlp_gpu = constrained_power_flow_model(data; backend=CUDABackend())\nresults = madnlp(nlp_gpu)\nnothing","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"MadNLP detects automatically that the ExaModel instance nlp_gpu has been instantiated on the GPU. As a result the solver is able to solve the instance entirely on the GPU with the linear solver cuDSS. Note that we converge to the same objective value, but the number of iterations is different, as well as the final convergence tolerance (tol=1e-4): when solving a model on the GPU with cuDSS, MadNLP has to use a few numerical tricks that impact slightly the accuracy in the evaluation. The tolerance has to be loosened to obtain a reliable convergence on the GPU. If you find the solution not satisfactory, you can specify your own convergence tolerance by using the option tol. E.g., to solve the model with the same precision as on the CPU:","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"results = madnlp(nlp_gpu; tol=1e-8)\nnothing","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"We have now all the elements in hand to solve the full optimal power flow problem on the GPU using MadNLP.","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"","category":"page"},{"location":"3-constrained-powerflow.html","page":"Tutorial 3: Constrained Power Flow","title":"Tutorial 3: Constrained Power Flow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: some info)","category":"page"},{"location":"index.html#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This page hosts the materials for the tutorial \"GPU-accelerated optimization for power systems with MadNLP and ExaModels\" presented at PowerTech 2025 by Alexis Montoison, François Pacaud and Sungho Shin.","category":"page"},{"location":"index.html#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The tutorials present how to solve the AC power flow using GPU-accelerated nonlinear programming. They proceed by order of difficulty, starting by the solution of the power flow equations and end with the solution of large-scale optimal power flow instances.","category":"page"},{"location":"index.html#Data","page":"Home","title":"Data","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"You can download all the instances we used in the tutorials on this webpage.","category":"page"},{"location":"index.html#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The table of contents is:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"0-crashcourse.md\", \"1-powerflow.md\", \"2-block-powerflow.md\", 3-constrained-powerflow.md\", \"4-optimal-powerflow\"]\nDepth = 2","category":"page"},{"location":"0-crashcourse.html#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"This first part is devoted to learning the basic of GPU programming. For those not familiar with the Julia language, we highly recommend reading this introduction to Julia.","category":"page"},{"location":"0-crashcourse.html#GPU-programming-using-CUDA.jl","page":"Getting Started","title":"GPU programming using CUDA.jl","text":"","category":"section"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"Julia has an excellent support for GPU programming with the organization JuliaGPU.","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"In this tutorial, we will focus on the library CUDA provided by NVIDIA. We recommend reading this tutorial to understand the basic concept for programming on the GPU with CUDA. Once installed, you can import CUDA as:","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"using CUDA","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"By default, you can allocate a new vector in Julia using","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"x_cpu = zeros(10)","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"The allocation of a new vector on the GPU has to be explicited as","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"x_gpu = CUDA.zeros(10)","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"By default, CUDA.jl allocates a vector of float. In scientific computing, it is often recommended to work with double, encoded by the type Float64 in Julia. This has to be explicited as","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"x_gpu = CUDA.zeros(Float64, 10)","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"The array can be manipulated using the broadcast operator (using a syntax similar as in matlab). Incrementing all the elements in x_gpu by 1 just amounts to","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"x_gpu .+= 1.0","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"info: Info\nOn the GPU, accessing the element of an array by its index (e.g. by calling x_gpu[1]) is prohibited by default, and should by avoided at all cost. The whole point of using a GPU is to evaluate operations in parallel, so it usually makes little sense to access an array element by element. If you have to implement non-trivial operations with complicated indexing operations, it is recommended to implement your custom GPU kernels.","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"In general,","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"We recommend using the broadcast operator . as much as you can, as it generates automatically the GPU kernels you need to implement the operation.\nMore complicated operations can be implemented with map or mapreduce, where Julia will generate the appropriate GPU kernels for you.\nOften you can use the BLAS functions provided by CUDA.jl, which are optimized for the GPU.\nIf you really have to, you can implement your own GPU kernel using CUDA.jl or using an abstraction layer like KernelAbstractions.jl.","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"Now comes the question of evaluating complicated expressions on the GPU.","category":"page"},{"location":"0-crashcourse.html#Modeling-with-ExaModels.jl","page":"Getting Started","title":"Modeling with ExaModels.jl","text":"","category":"section"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"In optimization, it is recommended to use a modeler to implement your model. The modeler acts as a domain specific language providing you the syntax needed to implement your optimization problem, and it converts the resulting problem in a form suitable for an optimization solver. Ampl, JuMP.jl and Pyomo are among the most popular modelers, but none of them support GPUs. ExaModels.jl is an attempt to fill this gap. ExaModels is designed to run on a variety of GPU architectures (NVIDIA, AMD, INTEL) as well as multi-threaded CPUs. As for CUDA.jl, we recommend this introductory course to ExaModels.","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"You can import ExaModels.jl simply as","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"using ExaModels","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"and instantiate a new model with","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"core = ExaCore()","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"Note that ExaModels supports multi-precision by default. Adding new variables to the model is very much similar to other modelers. E.g., adding 10 lower-bounded variables x  0 amounts to","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"x = variable(core, 10; lvar=0.0)","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"The keyword lvar is used to pass the lower-bounds on the variable x. Similarly, we can pass the upper-bounds using the keyword uvar, and a starting-point using the keyword start.","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"Once the variables are defined, ExaModels relies on a powerful SIMD abstraction to identify automatically the potential for parallelism in the expression tree. ExaModels implements the expression trees using iterator objects. As a consequence, we should define all the expressions in iterator format, and avoid accessing the variable x by its index outside a generator.","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"As a demonstration, we show how to generate the constraint 10  sin(x_i)  0. We start by building a Julia generator encoding the expression:","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"gen = (10.0 * sin(x[i]) + i for i in 1:10)","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"We can pass the generator gen to ExaModels to build our inequality constraints:","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"cons = constraint(core, gen; lcon=0.0)","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"info: Info\nAll the data arrays should have concrete, bit-type elements.","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"warning: Warning\nDo not place for loops outside of the generator. For instance, the code below:# Don't do this!\nfor i in 1:10\n    constraint(core, 10.0 * sin(x[i]) + i; lcon=0.0)\nendcan severely impact performance by generating a new kernel with each loop iteration, leading to increased compilation time. When working with ExaModels, always construct constraints using generators to clearly communicate the structure of the expressions.","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"Note that the generator just provides a way to generate expression. The evaluation part comes apart, by creating an ExaModel instance that takes as input the structure core that stores all the generators required to build the model:","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"nlp = ExaModel(core)","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"The constructor ExaModel generates an AbstractNLPModel, which comes with a proper API to evaluate the model in a syntax appropriate for numerical computing. The API can be found in this documentation. As a consequence, evaluating the constraints implemented by the generator we defined before just translates to:","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"using NLPModels\nx = ones(10)                # get an initial point\nc = NLPModels.cons(nlp, x)  # return the results as a vector","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"As ExaModels is just manipulating expressions, it is very easy to offload the evaluation of the model on the GPU. ExaModels builds automatically the appropriate kernels to evaluate the expressions implemented in the generators. You can generate a new model on the GPU simply by specifying a new backend to ExaModels:","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"core = ExaCore(; backend=CUDABackend())","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"The generation of the model on the GPU follows the same syntax:","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"x = variable(core, 10; lvar=0.0)\ncons = constraint(core, 10.0 * sin(x[i]) + i for i in 1:10; lcon=0.0)","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"as well as the model's evaluation:","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"nlp = ExaModel(core)\nx_gpu = CUDA.ones(Float64, 10)  # get an initial point\nc_gpu = NLPModels.cons(nlp, x_gpu)  # return the results as a vector","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"As we will see in the next tutorial, ExaModels is a powerful tool to evaluate the model's derivatives using automatic differentiation. This will prove to be particularly useful for solving the power flow equations.","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"0-crashcourse.html","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"2-batched-powerflow.html#Tutorial-2:-solving-the-power-flow-equations-in-batch-on-the-GPU","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: solving the power-flow equations in batch on the GPU","text":"","category":"section"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"In the previous tutorial, we have seen how to solve the power flow equations using ExaModels. Now, we want to fully leverage the capability of ExaModels to solve the power flow equations in batch on the GPU.","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"We start by importing the usual packages:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"using LinearAlgebra\nusing SparseArrays\n\nusing NLPModels\nusing ExaModels\n\nusing JLD2\n\ninclude(\"utils.jl\")","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"We load again the instance case9ieee:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"DATA_DIR = joinpath(splitdir(Base.active_project())[1], \"instances\")\ndata = JLD2.load(joinpath(DATA_DIR, \"case9.jld2\"))[\"data\"]\n\nnbus = length(data.bus)\nngen = length(data.gen)\nnlines = length(data.branch);\nnothing #hide","category":"page"},{"location":"2-batched-powerflow.html#Batched-power-flow-with-ExaModels","page":"Tutorial 2: Batched Power Flow","title":"Batched power flow with ExaModels","text":"","category":"section"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"The power flow are parameterized by the active and reactive power loads p_d and q_d at each bus, among others. This gives a total of 2*nbus parameters.","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"In this tutorial, we want to solve the power flow equations in batch for N different load scenarios  p_d^n q_d^n _n=1N, with N playing the role of the batch size. To each scenario (p_d^n q_d^n) is associated a block. The number of blocks is the batch size N.","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"As a demonstration, we set the batch size to 100:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"N = 100;\nnothing #hide","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"For each parameter (p_d^n q_d^n) is associated a given solution (v_m^n v_a^n p_g^n q_g^n) of the power flow equations. We will look at computing all the solutions in parallel using Newton.","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"Using ExaModels, we can define the corresponding batched model by augmenting the dimension of each variable with a second dimension parameterized by the batch size N. This amounts to define the following variables:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"core = ExaCore()\nva = variable(core, nbus, 1:N)\nvm = variable(core, nbus, 1:N; start = repeat(data.vm0, N))\npg = variable(core, ngen, 1:N;  start=repeat(data.pg0, N))\nqg = variable(core, ngen, 1:N;  start=repeat(data.qg0, N))\np = variable(core, 2*nlines, 1:N)\nq = variable(core, 2*nlines, 1:N);\nnothing #hide","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"Note that we have to duplicate N times the starting point for v_m, p_g and q_g. We also have to evaluate the power flow constraint in batch. As a consequence, the iterator used to generate each constraint has to be modified using the iterator product:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"c2 = constraint(\n    core,\n    p[b.f_idx, k]\n    - b.c5 * vm[b.f_bus, k]^2 -\n    b.c3 * (vm[b.f_bus, k] * vm[b.t_bus, k] * cos(va[b.f_bus, k] - va[b.t_bus, k])) -\n    b.c4 * (vm[b.f_bus, k] * vm[b.t_bus, k] * sin(va[b.f_bus, k] - va[b.t_bus, k])) for\n    (b, k) in product(data.branch, 1:N)\n)","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"To avoid redefining all the models, we provide a utility function to generate the batched power flow model using ExaModels:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"include(\"powerflow.jl\")\n\nnlp = batched_power_flow_model(data, N)","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"The power flow model can be solved on the CPU using the function solve_power_flow we implemented in the previous tutorial:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"results = solve_power_flow(nlp, N)\nnothing","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"We recover the solution in matrix format using:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"vm = reshape(results[nbus*N+1:2*nbus*N], nbus, N)","category":"page"},{"location":"2-batched-powerflow.html#Solving-the-power-flow-equations-in-batch-on-the-GPU","page":"Tutorial 2: Batched Power Flow","title":"Solving the power flow equations in batch on the GPU","text":"","category":"section"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"Note that we don't exploit in the algorithm the fact that the N blocks are independent. ExaModels is able to detect the repeated data structure automatically, and can evaluate the resulting model in parallel on the GPU. That's the core benefit of the SIMD abstraction used by ExaModels. To evaluate the model on the GPU using ExaModels, you just have to pass the correct backend to the function batched_power_flow_model we used just before:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"using CUDA\nnlp_gpu = batched_power_flow_model(data, N; backend=CUDABackend())\n\nn = NLPModels.get_nvar(nlp_gpu)\nm = NLPModels.get_ncon(nlp_gpu)\nnnzj = NLPModels.get_nnzj(nlp_gpu);\nnothing #hide","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"Evaluating the model on the GPU simply amounts to","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"x0 = NLPModels.get_x0(nlp_gpu)\nc = similar(x0, m)\nNLPModels.cons!(nlp_gpu, x0, c)","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"for the power flow residual, and for the Jacobian:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"Jx = similar(x0, nnzj)\nNLPModels.jac_coord!(nlp_gpu, x0, Jx)","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"We can benchmark the time spent in the evaluation of the derivative using the macro @time (or CUDA.@time if we want also to include the synchronization time in CUDA):","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"CUDA.@time NLPModels.cons!(nlp_gpu, x0, c)\nCUDA.@time NLPModels.jac_coord!(nlp_gpu, x0, Jx)\nnothing","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"We observe that the evaluation of the Jacobian takes 0.3ms in this case. In the function analyse_sparsity, we provide a sparse routine extracting the submatrix corresponding to the power flow equations from the Jacobian J.","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"info: Info\nOn the GPU, the default format for sparse matrices is CSR, as it leads to better parallelism when computing sparse-matrix vector products.","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"We can assemble the submatrix G using this new function:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"ind_dof = get_index_dof(data, N)\nm_fixed = length(ind_dof)\nind_dep = setdiff(1:n, ind_dof)\nnx = length(ind_dep)\n\nJi = similar(x0, Int, nnzj)\nJj = similar(x0, Int, nnzj)\nNLPModels.jac_structure!(nlp_gpu, Ji, Jj)\n\nG, coo_to_csr = analyse_sparsity(Ji, Jj, Jx, m, n, m_fixed, ind_dep);\nnothing #hide","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"Now the Jacobian is evaluated, we have to compute the LU factorization on the GPU, if possible in sparse format. The solver cuDSS allows to do exactly that. To use cuDSS in Julia, you have to import the package CUDSS","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"using CUDSS","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"We update the values in the Jacobian of the original model and transfer them to G using the same procedure as in Tutorial 1:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"NLPModels.jac_coord!(nlp_gpu, x0, Jx)\nnonzeros(G) .= Jx[coo_to_csr];\nnothing #hide","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"The symbolic factorization in cuDSS proceeds as follows:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"d_gpu = CUDA.zeros(Float64, nx)\nb_gpu = CUDA.zeros(Float64, nx)\n\nsolver = CudssSolver(G, \"G\", 'F')\ncudss_set(solver, \"reordering_alg\", \"algo2\") # we have to change the ordering to get valid results\ncudss(\"analysis\", solver, d_gpu, b_gpu)","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"Hence, we are now able to replace KLU by CUDSS in the Newton solver we implemented in the previous tutorial. We initialize the Newton algorithm by evaluating the model at the initial point:","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"ind_dep = CuVector{Int}(ind_dep)\nx = copy(x0)\nc = similar(x0, m)\nresidual = view(c, m_fixed+1:m)      # get subvector associated to the power flow residual\n\nNLPModels.cons!(nlp_gpu, x, c)\n\ncudss(\"factorization\", solver, d_gpu, b_gpu)\n\nmax_iter = 10\ntol = 1e-8\n\n@info \"Solving the power flow equations with Newton\"\ni = 1\nfor i in 1:max_iter\n    @info \"It: $(i) residual: $(norm(residual))\"\n    if norm(residual) <= tol\n        break\n    end\n    NLPModels.jac_coord!(nlp_gpu, x, Jx) # Update values in Jacobian\n    nonzeros(G) .= Jx[coo_to_csr]\n    cudss_set(solver, G)                 # Update numerical factorization\n    cudss(\"refactorization\", solver, d_gpu, b_gpu)\n    b_gpu .= residual\n    cudss(\"solve\", solver, d_gpu, b_gpu)\n    x[ind_dep] .-= d_gpu\n    NLPModels.cons!(nlp_gpu, x, c)\nend","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"We observe that we get exactly the same convergence as before on the CPU. However, the time to solution is significantly higher than on the CPU: it turns out that KLU is much more efficient than cuDSS on this particular example.","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"","category":"page"},{"location":"2-batched-powerflow.html","page":"Tutorial 2: Batched Power Flow","title":"Tutorial 2: Batched Power Flow","text":"This page was generated using Literate.jl.","category":"page"}]
}
